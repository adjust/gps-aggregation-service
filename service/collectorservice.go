// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package collectorservice contains the functions needed for the HTTP service which collects
// reports sent by the browsers.
package collectorservice

import (
	"context"
	"fmt"
	"net/http"
	"sync"
	"time"

	"github.com/ugorji/go/codec"
	"github.com/google/privacy-sandbox-aggregation-service/pipeline/dpfbrowsersimulator"
	"github.com/google/privacy-sandbox-aggregation-service/pipeline/ioutils"

	pb "github.com/google/privacy-sandbox-aggregation-service/pipeline/crypto_go_proto"
)

// The struct tags in the following structs need to be consistent with the field names defined in:
// https://github.com/WICG/conversion-measurement-api/blob/main/AGGREGATE.md#aggregate-attribution-reports

// AggregationServicePayload contains the payload for a specific helper server.
type AggregationServicePayload struct {
	Origin string `json:"origin"`
	// Payload is a encrypted CBOR serialized instance of struct dpfaggregator.Payload.
	Payload []byte `json:"payload"`
	KeyID   string `json:"key_id"`
}

// AggregationReport contains the information generated by the browser from a key-value pair,
// which will be used for server-side aggregation.
type AggregationReport struct {
	SourceSite             string `json:"source_site"`
	AttributionDestination string `json:"attribution_destination"`
	// SharedInfo is a CBOR serialized instance of struct SharedInfo.
	SharedInfo []byte                       `json:"shared_info"`
	Payloads   []*AggregationServicePayload `json:"aggregation_service_payloads"`
}

// SharedInfo contains the shared infomation that will be used as the context info for the hybrid encryption.
type SharedInfo struct {
	ScheduledReportTime int64  `json:"scheduled_report_time"`
	PrivacyBudgetKey    string `json:"privacy_budget_key"`
	Version             string `json:"version"`
	ReportingOrigin     string `json:"reporting_origin"`
}

// CollectorHandler handles the HTTPS requests with incoming reports.
//
// The server keeps receiving reports from the browsers until the number reaches a predefined batch size.
// Then the report batch is written into a file, which will be the input of the aggregation service.
type CollectorHandler struct {
	BatchSize                    int
	HelperOrigin1, HelperOrigin2 string
	BatchDir1, BatchDir2         string

	err                        error
	mu                         sync.Mutex
	reportBatch1, reportBatch2 []*pb.EncryptedPartialReportDpf
}

func (h *CollectorHandler) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	h.mu.Lock()
	defer h.mu.Unlock()
	if h.err != nil {
		http.Error(w, h.err.Error(), http.StatusInternalServerError)
		return
	}

	report := &AggregationReport{}
	if err := codec.NewDecoder(req.Body, &codec.CborHandle{}).Decode(report); err != nil {
		http.Error(w, "Failed in decoding CBOR message", http.StatusBadRequest)
		return
	}

	encrypted1, encrypted2, err := matchPayloads(report, h.HelperOrigin1, h.HelperOrigin2)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	h.reportBatch1 = append(h.reportBatch1, encrypted1)
	h.reportBatch2 = append(h.reportBatch2, encrypted2)

	if len(h.reportBatch1) == h.BatchSize {
		filename := time.Now().Format(time.RFC3339Nano)
		ctx := req.Context()
		if err := writeBatch(ctx, h.reportBatch1, ioutils.JoinPath(h.BatchDir1, filename)); err != nil {
			h.err = err
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		h.reportBatch1 = nil
		if err := writeBatch(ctx, h.reportBatch2, ioutils.JoinPath(h.BatchDir2, filename)); err != nil {
			h.err = err
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		h.reportBatch2 = nil
	}
}

func matchPayloads(report *AggregationReport, helperOrigin1, helperOrigin2 string) (encrypted1, encrypted2 *pb.EncryptedPartialReportDpf, err error) {
	if got, want := len(report.Payloads), 2; got != want {
		err = fmt.Errorf("expected %d payloads, got %d", want, got)
		return
	}
	gotOrigin1, gotOrigin2 := report.Payloads[0].Origin, report.Payloads[1].Origin
	var ciphertext1, ciphertext2 []byte
	if gotOrigin1 == helperOrigin1 && gotOrigin2 == helperOrigin2 {
		ciphertext1 = report.Payloads[0].Payload
		ciphertext2 = report.Payloads[1].Payload
	} else if gotOrigin1 == helperOrigin2 && gotOrigin2 == helperOrigin1 {
		ciphertext1 = report.Payloads[1].Payload
		ciphertext2 = report.Payloads[0].Payload
	} else {
		err = fmt.Errorf("expected helper origins %q and %q, got %q and %q", helperOrigin1, helperOrigin2, gotOrigin1, gotOrigin2)
		return
	}
	encrypted1 = &pb.EncryptedPartialReportDpf{
		EncryptedReport: &pb.StandardCiphertext{Data: ciphertext1},
		ContextInfo:     report.SharedInfo,
	}
	encrypted2 = &pb.EncryptedPartialReportDpf{
		EncryptedReport: &pb.StandardCiphertext{Data: ciphertext2},
		ContextInfo:     report.SharedInfo,
	}
	return
}

func writeBatch(ctx context.Context, batch []*pb.EncryptedPartialReportDpf, filename string) error {
	var lines []string
	for _, b := range batch {
		line, err := dpfbrowsersimulator.FormatEncryptedPartialReport(b)
		if err != nil {
			return err
		}
		lines = append(lines, line)
	}

	return ioutils.WriteLines(ctx, lines, filename)
}
