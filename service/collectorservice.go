// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package collectorservice contains the functions needed for the HTTP service which collects
// reports sent by the browsers.
package collectorservice

import (
	"context"
	"fmt"
	"net/http"
	"sync"
	"time"

	log "github.com/golang/glog"
	"github.com/ugorji/go/codec"
	"github.com/google/privacy-sandbox-aggregation-service/pipeline/dpfbrowsersimulator"
	"github.com/google/privacy-sandbox-aggregation-service/pipeline/ioutils"

	pb "github.com/google/privacy-sandbox-aggregation-service/pipeline/crypto_go_proto"
)

// The struct tags in the following structs need to be consistent with the field names defined in:
// https://github.com/WICG/conversion-measurement-api/blob/main/AGGREGATE.md#aggregate-attribution-reports

// AggregationServicePayload contains the payload for a specific helper server.
type AggregationServicePayload struct {
	Origin string `json:"origin"`
	// Payload is a encrypted CBOR serialized instance of struct dpfaggregator.Payload.
	Payload []byte `json:"payload"`
	KeyID   string `json:"key_id"`
}

// AggregationReport contains the information generated by the browser from a key-value pair,
// which will be used for server-side aggregation.
type AggregationReport struct {
	SourceSite             string `json:"source_site"`
	AttributionDestination string `json:"attribution_destination"`
	// SharedInfo is a CBOR serialized instance of struct SharedInfo.
	SharedInfo []byte                       `json:"shared_info"`
	Payloads   []*AggregationServicePayload `json:"aggregation_service_payloads"`
}

// SharedInfo contains the shared infomation that will be used as the context info for the hybrid encryption.
type SharedInfo struct {
	ScheduledReportTime int64  `json:"scheduled_report_time"`
	PrivacyBudgetKey    string `json:"privacy_budget_key"`
	Version             string `json:"version"`
	ReportingOrigin     string `json:"reporting_origin"`
}

// CollectorHandler handles the HTTPS requests with incoming reports.
//
// The server keeps receiving reports from the browsers and tracks the number of reports per pair
// of helper origins. When the report number reaches the predefined batch size, the reports are
// written into two files, which will be the input of the aggregation service for the corresponding helpers.
type CollectorHandler struct {
	BatchSize int
	BatchDir  string

	err         error
	mu          sync.Mutex
	reportBatch map[string][]*pb.EncryptedPartialReportDpf
}

// NewHandler creates a new CollectorHandler with initialized values
func NewHandler(batchSize int, batchDir string) http.Handler {
	return &CollectorHandler{
		BatchDir:    batchDir,
		BatchSize:   batchSize,
		reportBatch: make(map[string][]*pb.EncryptedPartialReportDpf),
	}
}

func (h *CollectorHandler) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	h.mu.Lock()
	defer h.mu.Unlock()
	if h.err != nil {
		http.Error(w, h.err.Error(), http.StatusInternalServerError)
		log.Error(h.err.Error())
		return
	}

	report := &AggregationReport{}
	if err := codec.NewDecoder(req.Body, &codec.CborHandle{}).Decode(report); err != nil {
		errMsg := "Failed in decoding CBOR message"
		http.Error(w, errMsg, http.StatusBadRequest)
		log.Error(errMsg, err)
		return
	}

	batchKey1, batchKey2, err := collectPayloads(report, h.reportBatch)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		log.Error(err.Error())
		return
	}

	if len(h.reportBatch[batchKey1]) == h.BatchSize {
		timestamp := time.Now().Format(time.RFC3339Nano)
		ctx := req.Context()
		log.Infof("Writing batch for %v to: %v", batchKey1, ioutils.JoinPath(h.BatchDir, fmt.Sprintf("%s-%s", batchKey1, timestamp)))
		if err := writeBatch(ctx, h.reportBatch[batchKey1], ioutils.JoinPath(h.BatchDir, fmt.Sprintf("%s-%s", batchKey1, timestamp))); err != nil {
			h.err = err
			http.Error(w, err.Error(), http.StatusInternalServerError)
			log.Error(err.Error())
			return
		}
		h.reportBatch[batchKey1] = nil
		log.Infof("Writing batch for %v to: %v", batchKey2, ioutils.JoinPath(h.BatchDir, fmt.Sprintf("%s-%s", batchKey2, timestamp)))
		if err := writeBatch(ctx, h.reportBatch[batchKey2], ioutils.JoinPath(h.BatchDir, fmt.Sprintf("%s-%s", batchKey2, timestamp))); err != nil {
			h.err = err
			http.Error(w, err.Error(), http.StatusInternalServerError)
			log.Error(err.Error())
			return
		}
		h.reportBatch[batchKey2] = nil
	}
}

func collectPayloads(report *AggregationReport, batch map[string][]*pb.EncryptedPartialReportDpf) (string, string, error) {
	if got, want := len(report.Payloads), 2; got != want {
		return "", "", fmt.Errorf("expected %d payloads, got %d", want, got)
	}
	origin1, origin2 := report.Payloads[0].Origin, report.Payloads[1].Origin
	if origin1 == origin2 {
		return "", "", fmt.Errorf("secret shares sending to the same helper %q", origin1)
	}

	ciphertext1, ciphertext2 := report.Payloads[0].Payload, report.Payloads[1].Payload
	if origin1 > origin2 {
		origin1, origin2 = origin2, origin1
		ciphertext1, ciphertext2 = ciphertext2, ciphertext1
	}

	batchKey := fmt.Sprintf("%s+%s", origin1, origin2)
	batchKey1, batchKey2 := batchKey+"+1", batchKey+"+2"
	batch[batchKey1] = append(batch[batchKey1], &pb.EncryptedPartialReportDpf{
		EncryptedReport: &pb.StandardCiphertext{Data: ciphertext1},
		ContextInfo:     report.SharedInfo,
	})
	batch[batchKey2] = append(batch[batchKey2], &pb.EncryptedPartialReportDpf{
		EncryptedReport: &pb.StandardCiphertext{Data: ciphertext2},
		ContextInfo:     report.SharedInfo,
	})
	return batchKey1, batchKey2, nil
}

func writeBatch(ctx context.Context, batch []*pb.EncryptedPartialReportDpf, filename string) error {
	var lines []string
	for _, b := range batch {
		line, err := dpfbrowsersimulator.FormatEncryptedPartialReport(b)
		if err != nil {
			return err
		}
		lines = append(lines, line)
	}

	return ioutils.WriteLines(ctx, lines, filename)
}
